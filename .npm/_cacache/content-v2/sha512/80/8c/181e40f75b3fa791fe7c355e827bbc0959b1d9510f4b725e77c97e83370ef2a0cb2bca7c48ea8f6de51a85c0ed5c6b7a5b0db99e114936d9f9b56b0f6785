{"_id":"@sindresorhus/jimp","_rev":"2-13bcad821be976b46ec51c9976bfcf59","name":"@sindresorhus/jimp","dist-tags":{"latest":"0.3.0"},"versions":{"0.3.0":{"name":"@sindresorhus/jimp","version":"0.3.0","description":"[Forked to be able to use the latest master] An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).","main":"jimp.js","types":"./jimp.d.ts","scripts":{"lint":"npm run -s lint:src && npm run -s lint:browser && npm run -s lint:tests && npm run -s lint:extra && echo Lint All Success","lint:src":"eslint *.js src/*.js browser/src/*.js && echo Lint Source Success","lint:tests":"eslint --env 'mocha' --rule '{no-new: \"off\"}' test/*.js && echo Lint Tests Success","lint:browser":"eslint --rule '{no-new: \"off\"}' browser/src/*.js && echo Lint Browser Success","lint:extra":"eslint --rule '{no-console: \"off\"}' {*/,}{tools,examples}/*.js && echo Lint Extras Success","test:node:run":"mocha","test:node:once":"istanbul cover _mocha ./test/*.test.js","test:node:once:nocover":"mocha ./test/*.test.js","test:node:watch":"mocha --reporter min --watch ./test/*.test.js","test:without-lint":"npm run -s test:node:once && npm run -s test:browser:once","test":"npm run -s lint && npm run -s test:without-lint","test:old":"./test/tests.sh","start":"node server.js"},"keywords":["image","image processing","image manipulation","png","jpg","jpeg","bmp","resize","scale","crop"],"author":{"name":"Oliver Moran","email":"oliver.moran@gmail.com"},"license":"MIT","dependencies":{"bignumber.js":"^2.1.0","bmp-js":"0.0.3","exif-parser":"^0.1.9","file-type":"^3.1.0","jpeg-js":"^0.2.0","load-bmfont":"^1.2.3","mime":"^1.3.4","mkdirp":"0.5.1","pixelmatch":"^4.0.0","pngjs":"^3.0.0","raw-body":"^2.3.2","tinycolor2":"^1.1.2","utif":"^1.1.2"},"devDependencies":{"babel":"^6.0.14","babel-cli":"^6.0.0","babel-preset-es2015":"^6.0.14","babel-preset-stage-0":"^6.0.14","browserify":"^14.3.0","envify":"^3.4.0","eslint":"^3.14.1","eslint-config-standard":"^6.2.1","eslint-plugin-promise":"^3.4.1","eslint-plugin-standard":"^2.0.1","express":"^4.13.4","istanbul":"^0.4.5","karma":"^1.4.0","karma-chrome-launcher":"^2.0.0","karma-firefox-launcher":"^1.0.0","karma-generic-preprocessor":"^1.1.0","karma-mocha":"^1.3.0","karma-mocha-own-reporter":"^1.1.2","mocha":"^3.2.0","should":"^11.1.2","uglify-js":"^2.7.5"},"repository":{"type":"git","url":"git+https://github.com/oliver-moran/jimp.git"},"bugs":{"url":"https://github.com/oliver-moran/jimp/issues"},"tonicExampleFilename":"example.js","gitHead":"a0c477a8a342226d66a66eebb3f28aa8692bed80","homepage":"https://github.com/oliver-moran/jimp#readme","_id":"@sindresorhus/jimp@0.3.0","_npmVersion":"6.0.0","_nodeVersion":"8.11.1","_npmUser":{"name":"sindresorhus","email":"sindresorhus@gmail.com"},"dist":{"integrity":"sha512-ikwHOfJF0umx1eV/JpQDMsFxODvCSdD9zdIQVDEjcTNpfofz7+PZrjfKUFkG3iQ9mSUG3BwODv0XOEvTRNdovw==","shasum":"c9c42f716bf47e5c9f6608a5349f31db3a016f5b","tarball":"https://registry.npmjs.org/@sindresorhus/jimp/-/jimp-0.3.0.tgz","fileCount":46,"unpackedSize":966054,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJa81LhCRA9TVsSAnZWagAAbi8P+QBiBJnkPhgXpBbQZefC\n2/IwecrqQvbLrn9gs++gJsgC6S6gaUiNv866FKCptjBXoDUkZqsEEpmiFywg\nZgjpxrfEq11U2CCon0XdVVgYJNy/BiFVtBtA7rNd3Dg7D/h3sRhLBp9GBRWJ\nCUVAUhQo338UWqrUNQ0SL849I5GUzj17MHv5IvKytsSVEQ8WXlyrOrMvL+PL\n43COjkTlWFENkDsApedAUxotW+GTVCy6wbt8rzX23hO4Q/3G+0tthfgOTjIv\n3F9MF51qutuYZLyaXcD7o+Pj8uta2nxG1cZJmaKTx3EeoO2Msa4Hhl44kJfd\nKS/r9kJCzDBrfS89JpR5x7saYr3lFRTvMRrwm0L9TfJPrpRFh4xryVQ3OdQ7\nvZrlaz6O6lBS35Dn4WTZZjdJcQwRAS/ZQjjhwa2Qv6Qj9bb07AHM/6ETI1pk\nyS0mFQ29Jh2SQ5yOOy2VhaWcBGpvRIhVcsi5RGQ3+iWrKxgaOiL9zUuWI/5N\nrDjEDihAaJOrNCuwvSoOjvKfpqZ/cn61pq14Isq7P1EBDdRq+XdYVALTYzgL\n9vxih+4v7cMdHmAJ+CuYonD9lqQOm3+DjrWv2bhMl2cGz0L7RgmMcZ367MOo\n6cB+oV7jasBVgGq9YkJ4/2gmaHXPwiPTfb2dD0KidPYXBKn2uTZNy414i2ZD\nRS4o\r\n=HCkJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDcRLJjWbgeIDwHvdVw1egZZ8r67byMpCskBleL2lL2UgIgDriioEPtI5Gx7H3iPYsfyMg1cQZppWZaDV5TFb1fD6E="}]},"maintainers":[{"name":"sindresorhus","email":"sindresorhus@gmail.com"}],"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jimp_0.3.0_1525895903274_0.3086766574407416"},"_hasShrinkwrap":false,"deprecated":"Deprecated. Use the original package instead: https://www.npmjs.com/package/jimp"}},"time":{"created":"2018-05-09T19:58:23.190Z","0.3.0":"2018-05-09T19:58:23.417Z","modified":"2024-05-02T18:42:09.520Z"},"maintainers":[{"name":"sindresorhus","email":"sindresorhus@gmail.com"}],"description":"[Forked to be able to use the latest master] An image processing library written entirely in JavaScript (i.e. zero external or native dependencies).","homepage":"https://github.com/oliver-moran/jimp#readme","keywords":["image","image processing","image manipulation","png","jpg","jpeg","bmp","resize","scale","crop"],"repository":{"type":"git","url":"git+https://github.com/oliver-moran/jimp.git"},"author":{"name":"Oliver Moran","email":"oliver.moran@gmail.com"},"bugs":{"url":"https://github.com/oliver-moran/jimp/issues"},"license":"MIT","readme":"# Jimp #\n\n**Forked to be able to use the latest master**\n\nThe \"JavaScript Image Manipulation Program\" :-)\n\nAn image processing library for Node written entirely in JavaScript, with zero native dependencies.\n\nInstallation: `npm install --save jimp`\n\nExample usage:\n\n```js\nvar Jimp = require(\"jimp\");\n\n// open a file called \"lenna.png\"\nJimp.read(\"lenna.png\", function (err, lenna) {\n    if (err) throw err;\n    lenna.resize(256, 256)            // resize\n         .quality(60)                 // set JPEG quality\n         .greyscale()                 // set greyscale\n         .write(\"lena-small-bw.jpg\"); // save\n});\n```\n\nUsing promises:\n\n```js\nJimp.read(\"lenna.png\").then(function (lenna) {\n    return lenna.resize(256, 256)     // resize\n         .quality(60)                 // set JPEG quality\n         .greyscale()                 // set greyscale\n         .write(\"lena-small-bw.jpg\"); // save\n}).catch(function (err) {\n    console.error(err);\n});\n```\n\n## Basic usage ##\n\nThe static `Jimp.read` method takes the path to a PNG, JPEG or BMP file and returns a Promise:\n\n```js\nJimp.read(\"./path/to/image.jpg\").then(function (image) {\n    // do stuff with the image\n}).catch(function (err) {\n    // handle an exception\n});\n```\n\nThe method can also read a PNG, JPEG or BMP buffer or from a URL:\n\n```js\nJimp.read(lenna.buffer).then(function (image) {\n    // do stuff with the image\n}).catch(function (err) {\n    // handle an exception\n});\n\nJimp.read(\"http://www.example.com/path/to/lenna.jpg\").then(function (image) {\n    // do stuff with the image\n}).catch(function (err) {\n    // handle an exception\n});\n```\n\n\n### Basic methods ###\n\nOnce the promise is fulfilled, the following methods can be called on the image:\n\n```js\n/* Resize */\nimage.contain( w, h[, alignBits || mode, mode] );    // scale the image to the given width and height, some parts of the image may be letter boxed\nimage.cover( w, h[, alignBits || mode, mode] );      // scale the image to the given width and height, some parts of the image may be clipped\nimage.resize( w, h[, mode] );     // resize the image. Jimp.AUTO can be passed as one of the values.\nimage.scale( f[, mode] );         // scale the image by the factor f\nimage.scaleToFit( w, h[, mode] ); // scale the image to the largest size that fits inside the given width and height\n\n// An optional resize mode can be passed with all resize methods.\n\n/* Crop */\nimage.autocrop([tolerance, frames]); // automatically crop same-color borders from image (if any), frames must be a Boolean\nimage.crop( x, y, w, h );         // crop to the given region\n\n/* Composing */\nimage.blit( src, x, y[, srcx, srcy, srcw, srch] );\n                                  // blit the image with another Jimp image at x, y, optionally cropped.\nimage.composite( src, x, y );     // composites another Jimp image over this image at x, y\nimage.mask( src, x, y );          // masks the image with another Jimp image at x, y using average pixel value\nimage.convolute( kernel );        // applies a convolution kernel matrix to the image or a region\n\n/* Flip and rotate */\nimage.flip( horz, vert );         // flip the image horizontally or vertically\nimage.mirror( horz, vert );       // an alias for flip\nimage.rotate( deg[, mode] );      // rotate the image clockwise by a number of degrees. Optionally, a resize mode can be passed. If `false` is passed as the second parameter, the image width and height will not be resized.\nimage.exifRotate();               // JPEG images with EXIF orientation data will be automatically re-orientated as appropriate.\n\n/* Colour */\nimage.brightness( val );          // adjust the brighness by a value -1 to +1\nimage.contrast( val );            // adjust the contrast by a value -1 to +1\nimage.dither565();                // ordered dithering of the image and reduce color space to 16-bits (RGB565)\nimage.greyscale();                // remove colour from the image\nimage.invert();                   // invert the image colours\nimage.normalize();                // normalize the channels in an image\n\n/* Alpha channel */\nimage.fade( f );                  // an alternative to opacity, fades the image by a factor 0 - 1. 0 will haven no effect. 1 will turn the image\nimage.opacity( f );               // multiply the alpha channel by each pixel by the factor f, 0 - 1\nimage.opaque();                   // set the alpha channel on every pixel to fully opaque\nimage.background( hex );          // set the default new pixel colour (e.g. 0xFFFFFFFF or 0x00000000) for by some operations (e.g. image.contain and\n\n/* Blurs */\nimage.gaussian( r );              // Gaussian blur the image by r pixels (VERY slow)\nimage.blur( r );                  // fast blur the image by r pixels\n\n/* Effects */\nimage.posterize( n );             // apply a posterization effect with n level\nimage.sepia();                    // apply a sepia wash to the image\nimage.pixelate( size[, x, y, w, h ]);  // apply a pixelation effect to the image or a region\n\n/* 3D */\nimage.displace( map, offset );    // displaces the image pixels based on the provided displacement map. Useful for making stereoscopic 3D images.\n```\n\nSome of these methods are irreversable, so it can be useful to perform them on a clone of the original image:\n\n```js\nimage.clone();                    // returns a clone of the image\n```\n\n(Contributions of more methods are welcome!)\n\n### Resize modes ###\n\nThe default resizing algorithm uses a bilinear method as follows:\n\n```js\nimage.resize(250, 250);           // resize the image to 250 x 250\nimage.resize(Jimp.AUTO, 250);     // resize the height to 250 and scale the width accordingly\nimage.resize(250, Jimp.AUTO);     // resize the width to 250 and scale the height accordingly\n```\n\nOptionally, the following constants can be passed to choose a particular resizing algorithm:\n\n```js\nJimp.RESIZE_NEAREST_NEIGHBOR;\nJimp.RESIZE_BILINEAR;\nJimp.RESIZE_BICUBIC;\nJimp.RESIZE_HERMITE;\nJimp.RESIZE_BEZIER;\n```\n\nFor example:\n\n```js\nimage.resize(250, 250, Jimp.RESIZE_BEZIER);\n```\n\n### Align modes ###\n\nThe following constants can be passed to image.cover and image.contain methods:\n\n```js\nJimp.HORIZONTAL_ALIGN_LEFT;\nJimp.HORIZONTAL_ALIGN_CENTER;\nJimp.HORIZONTAL_ALIGN_RIGHT;\n\nJimp.VERTICAL_ALIGN_TOP;\nJimp.VERTICAL_ALIGN_MIDDLE;\nJimp.VERTICAL_ALIGN_BOTTOM;\n```\n\nFor example:\n\n```js\nimage.contain(250, 250, Jimp.HORIZONTAL_ALIGN_LEFT | Jimp.VERTICAL_ALIGN_TOP);\n```\n\nDefault align modes are :\n\n```js\nJimp.HORIZONTAL_ALIGN_CENTER | Jimp.VERTICAL_ALIGN_MIDDLE;\n```\n\n### Writing text ###\n\nJimp supports basic typography using BMFont format (.fnt) [bitmap fonts](https://en.wikipedia.org/wiki/Bitmap_fonts):\n\n```js\nJimp.loadFont( path ).then(function (font) { // load font from .fnt file\n    image.print(font, x, y, str);        // print a message on an image\n    image.print(font, x, y, str, width); // print a message on an image with text wrapped at width\n});\n\nJimp.loadFont( path, cb ); // using a callback pattern\n```\n\nBMFont fonts are raster based and fixed in size and colour. Jimp comes with a set of fonts that can be used on images:\n\n```js\nJimp.FONT_SANS_8_BLACK;   // Open Sans, 8px, black\nJimp.FONT_SANS_10_BLACK;   // Open Sans, 10px, black\nJimp.FONT_SANS_12_BLACK;   // Open Sans, 12px, black\nJimp.FONT_SANS_14_BLACK;   // Open Sans, 14px, black\nJimp.FONT_SANS_16_BLACK;  // Open Sans, 16px, black\nJimp.FONT_SANS_32_BLACK;  // Open Sans, 32px, black\nJimp.FONT_SANS_64_BLACK;  // Open Sans, 64px, black\nJimp.FONT_SANS_128_BLACK; // Open Sans, 128px, black\n\nJimp.FONT_SANS_8_WHITE;   // Open Sans, 8px, white\nJimp.FONT_SANS_16_WHITE;  // Open Sans, 16px, white\nJimp.FONT_SANS_32_WHITE;  // Open Sans, 32px, white\nJimp.FONT_SANS_64_WHITE;  // Open Sans, 64px, white\nJimp.FONT_SANS_128_WHITE; // Open Sans, 128px, white\n```\n\nThese can be used as follows:\n\n```js\nJimp.loadFont(Jimp.FONT_SANS_32_BLACK).then(function (font) {\n    image.print(font, 10, 10, \"Hello world!\");\n});\n```\n\nOnline tools are also available to convert TTF fonts to BMFont format (e.g. [Littera](http://kvazars.com/littera/)).\n\n## Writing to files and buffers ##\n\n### Writing to files ###\n\nThe image can be written to disk in PNG, JPEG or BMP format (determined by the file extension) using:\n\n```js\nimage.write( path, cb ); // Node-style callback will be fired when write is successful\n```\n\nThe original extension for an image (or \"png\") can accessed as using `image.getExtension()`. The following will save an image using its original format:\n\n```js\nvar file = \"new_name.\" + image.getExtension();\nimage.write(file)\n```\n\n### Writing to Buffers ###\n\nA PNG, JPEG or BMP binary Buffer of an image (e.g. for storage in a database) can be obtained using:\n\n```js\nimage.getBuffer( mime, cb ); // Node-style callback will be fired with result\n```\n\nFor convenience, supported MIME types are available as static properties:\n\n```js\nJimp.MIME_PNG;  // \"image/png\"\nJimp.MIME_JPEG; // \"image/jpeg\"\nJimp.MIME_BMP;  // \"image/bmp\"\n```\n\nIf `Jimp.AUTO` is passed as the MIME type then the original MIME type for the image (or \"image/png\") will be used. Alernatively, `image.getMIME()` will return the original MIME type of the image (or \"image/png\").\n\n### Data URI ###\n\nA Base64 data URI can be generated in the same way as a Buffer, using:\n\n```js\nimage.getBase64( mime, cb ); // Node-style callback will be fired with result\n```\n\n### PNG and JPEG quality ###\n\nThe quality of JPEGs can be set with:\n\n```js\nimage.quality( n ); // set the quality of saved JPEG, 0 - 100\n```\n\nThe format of PNGs can be set with:\n\n```js\nimage.rgba( bool );             // set whether PNGs are saved as RGBA (true, default) or RGB (false)\nimage.filterType( number );     // set the filter type for the saved PNG\nimage.deflateLevel( number );   // set the deflate level for the saved PNG\nJimp.deflateStrategy( number ); // set the deflate for the saved PNG (0-3)\n```\n\nFor convenience, supported filter types are available as static properties:\n\n```js\nJimp.PNG_FILTER_AUTO;    // -1\nJimp.PNG_FILTER_NONE;    //  0\nJimp.PNG_FILTER_SUB;     //  1\nJimp.PNG_FILTER_UP;      //  2\nJimp.PNG_FILTER_AVERAGE; //  3\nJimp.PNG_FILTER_PAETH;   //  4\n```\n\n## Advanced usage ##\n\n### Colour manipulation ##\n\nJimp supports advanced colour manipulation using a single method as follows:\n\n```js\nimage.color([\n    { apply: 'hue', params: [ -90 ] },\n    { apply: 'lighten', params: [ 50 ] },\n    { apply: 'xor', params: [ '#06D' ] }\n]);\n```\n\nThe method supports the following modifiers:\n\nModifier                | Description\n----------------------- | -----------------------\n**lighten** {amount}    | Lighten the color a given amount, from 0 to 100. Providing 100 will always return white (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**brighten** {amount}   | Brighten the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**darken** {amount}     | Darken the color a given amount, from 0 to 100. Providing 100 will always return black (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**desaturate** {amount} | Desaturate the color a given amount, from 0 to 100. Providing 100 will is the same as calling greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**saturate** {amount}   | Saturate the color a given amount, from 0 to 100 (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**greyscale** {amount}  | Completely desaturates a color into greyscale (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**spin** {degree}       | Spin the hue a given amount, from -360 to 360. Calling with 0, 360, or -360 will do nothing - since it sets the hue back to what it was before. (works through [TinyColor](https://github.com/bgrins/TinyColor))\n**hue** {degree}        | Alias for **spin**\n**mix** {color, amount} | Mixes colors by their RGB component values. Amount is opacity of overlaying color\n**tint** {amount}       | Same as applying **mix** with white color\n**shade** {amount}      | Same as applying **mix** with black color\n**xor** {color}         | Treats the two colors as bitfields and applies an XOR operation to the red, green, and blue components\n**red** {amount}        | Modify Red component by a given amount\n**green** {amount}      | Modify Green component by a given amount\n**blue** {amount}       | Modify Blue component by a given amount\n\n### Convolution matrix ###\n\nSum neighbor pixels weighted by the kernel matrix. You can find a nice explanation with examples at [GIMP's Convolution Matrix plugin](https://docs.gimp.org/en/plug-in-convmatrix.html)\n\nImplement emboss effect:\n```js\n  image.convolute([\n    [-2,-1, 0],\n    [-1, 1, 1],\n    [ 0, 1, 2]\n  ])\n```\n\n### Low-level manipulation ###\n\nJimp enables low-level manipulation of images in memory through the bitmap property of each Jimp object:\n\n```js\nimage.bitmap.data;  // a Buffer of the raw bitmap data\nimage.bitmap.width; // the width of the image\nimage.bitmap.height // the height of the image\n```\n\nThis data can be manipulated directly but remember: garbage in, garbage out.\n\nA helper method is available to scan a region of the bitmap:\n\n```js\nimage.scan(x, y, w, h, f); // scan a given region of the bitmap and call the function f on every pixel\n```\n\nExample usage:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, idx) {\n    // x, y is the position of this pixel on the image\n    // idx is the position start position of this rgba tuple in the bitmap Buffer\n    // this is the image\n\n    var red   = this.bitmap.data[ idx + 0 ];\n    var green = this.bitmap.data[ idx + 1 ];\n    var blue  = this.bitmap.data[ idx + 2 ];\n    var alpha = this.bitmap.data[ idx + 3 ];\n\n    // rgba values run from 0 - 255\n    // e.g. this.bitmap.data[idx] = 0; // removes red from this pixel\n});\n```\n\nIf you need to do something with the image at the end of the scan:\n\n```js\nimage.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, idx) {\n    // do your stuff..\n\n    if(x == image.bitmap.width-1 &&\n        y == image.bitmap.height-1) {\n        // image scan finished, do your stuff\n    }\n});\n```\n\nA helper to locate a particular pixel within the raw bitmap buffer:\n\n```js\nimage.getPixelIndex(x, y); // returns the index within image.bitmap.data\n```\n\nOne of the following may be optionally passed as a third parameter to indicate a strategy for x, y positions that are outside of boundaries of the image:\n\n```js\nJimp.EDGE_EXTEND = 1;\nJimp.EDGE_WRAP = 2;\nJimp.EDGE_CROP = 3;\n```\n\nAlternatively, you can manipulate individual pixels using the following these functions:\n\n```js\nimage.getPixelColor(x, y);      // returns the colour of that pixel e.g. 0xFFFFFFFF\nimage.setPixelColor(hex, x, y); // sets the colour of that pixel\n```\n\nTwo static helper functions exist to convert RGBA values into single integer (hex) values:\n\n```js\nJimp.rgbaToInt(r, g, b, a); // e.g. converts 255, 255, 255, 255 to 0xFFFFFFFF\nJimp.intToRGBA(hex);        // e.g. converts 0xFFFFFFFF to {r: 255, g: 255, b: 255, a:255}\n```\n\n### Creating new images ###\n\nIf you want to begin with an empty Jimp image, you can call the Jimp constructor passing the width and height of the image to create and (optionally) a Node-style callback:\n\n```js\nvar image = new Jimp(256, 256, function (err, image) {\n    // this image is 256 x 256, every pixel is set to 0x00000000\n});\n```\n\nYou can optionally set the pixel colour as follows:\n\n```js\nvar image = new Jimp(256, 256, 0xFF0000FF, function (err, image) {\n    // this image is 256 x 256, every pixel is set to 0xFF0000FF\n});\n```\n\n## Comparing images ##\n\nTo generate a [perceptual hash](https://en.wikipedia.org/wiki/Perceptual_hashing) of a Jimp image, based on the [pHash](http://phash.org/) algorithm, use:\n\n```js\nimage.hash(); // aHgG4GgoFjA\n```\n\nBy default the hash is returned as base 64. The hash can be returned at another base by passing a number from 2 to 64 to the method:\n\n```js\nimage.hash(2); // 1010101011010000101010000100101010010000011001001001010011100100\n```\n\nThere are 18,446,744,073,709,551,615 unique hashes. The hamming distance between the binary representation of these hashes can be used to find similar-looking images.\n\nTo calculate the hamming distance between two Jimp images based on their perceptual hash use:\n\n```js\nJimp.distance(image1, image2); // returns a number 0-1, where 0 means the two images are perceived to be identical\n```\n\nJimp also allows the diffing of two Jimp images using [PixelMatch](https://github.com/mapbox/pixelmatch) as follows:\n\n```js\nvar diff = Jimp.diff(image1, image2, threshold); // threshold ranges 0-1 (default: 0.1)\ndiff.image;   // a Jimp image showing differences\ndiff.percent; // the proportion of different pixels (0-1), where 0 means the images are pixel identical\n```\n\nUsing a mix of hamming distance and pixel diffing to comare images, the following code has a 99% success rate of detecting the same image from a random sample (with 1% false positives). The test this figure is drawn from attempts to match each image from a sample of 120 PNGs against 120 corresponing JPEGs saved at a quality setting of 60.\n\n```js\nvar distance = Jimp.distance(png, jpeg); // perceived distance\nvar diff = Jimp.diff(png, jpeg);         // pixel difference\n\nif (distance < 0.15 || diff.percent < 0.15) {\n    // images match\n} else {\n    // not a match\n}\n```\n\n## Chaining or callbacks ##\n\nMost instance methods can be chained together, for example as follows:\n\n```js\nJimp.read(\"lenna.png\", function (err, image) {\n    this.greyscale().scale(0.5).write(\"lena-half-bw.png\");\n});\n```\n\nAlternatively, methods can be passed Node-style callbacks:\n\n```js\nJimp.read(\"lenna.png\", function (err, image) {\n    image.greyscale(function(err, image) {\n        image.scale(0.5, function (err, image) {\n            image.write(\"lena-half-bw.png\");\n        });\n    });\n});\n```\n\nThe Node-style callback pattern allows Jimp to be used with frameworks that expect or build on the Node-style callback pattern.\n\n## Contributing ##\n\nBasicaly clone, change, test, push and pull request.\nPlease read de [CONTRIBUTING documentation](CONTRIBUTING.md).\n\n### Testing ###\n\nThe test framework runs at node.js and browsers environments. Just run `npm test` to test in node and browser environments.\nMore information at [\"How to Contribute\" doc's \"Testing\" topic](CONTRIBUTING.md#testing).\n\n## License ##\n\nJimp is licensed under the MIT license. Open Sans is licensed under the Apache license.\n","readmeFilename":"README.md"}